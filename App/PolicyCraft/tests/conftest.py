"""
Test configuration and fixtures for PolicyCraft
Provides reusable test data and mock objects for comprehensive testing.

Author: Jacek Robert Kszczot
Project: MSc AI & Data Science - COM7016
"""

import pytest
import tempfile
import os
from unittest.mock import Mock, MagicMock
import json
from datetime import datetime

# Test data constants
SAMPLE_POLICY_TEXT = """
University AI Policy

1. Purpose and Scope
This policy establishes guidelines for the responsible use of artificial intelligence tools in academic contexts.

2. Disclosure Requirements
Students and faculty must disclose the use of AI tools in their academic work. All AI-generated content must be clearly acknowledged and properly cited.

3. Academic Integrity
The use of AI tools must maintain academic integrity standards. Students remain responsible for the accuracy and originality of their submitted work.

4. Assessment Guidelines
Faculty may specify restrictions on AI use for particular assessments. Students should seek approval before using AI tools for major assignments.

5. Data Privacy
Users must not input confidential or personal data into AI systems. All data privacy regulations must be observed.

6. Human Oversight
All AI-generated content must be reviewed and validated by human judgment. Faculty maintain final authority over academic decisions.
"""

SAMPLE_THEMES = [
    {"name": "AI Ethics", "score": 0.85, "confidence": 92},
    {"name": "Academic Integrity", "score": 0.78, "confidence": 89},
    {"name": "Disclosure Requirements", "score": 0.72, "confidence": 87},
    {"name": "Privacy and Data", "score": 0.65, "confidence": 84},
    {"name": "Human Oversight", "score": 0.58, "confidence": 81},
    {"name": "Assessment Guidelines", "score": 0.52, "confidence": 78}
]

SAMPLE_CLASSIFICATION = {
    "classification": "Moderate",
    "confidence": 67,
    "method": "hybrid",
    "reasoning": "Policy contains balanced approach with disclosure requirements and human oversight"
}

@pytest.fixture
def sample_policy_text():
    """Sample AI policy text for testing text processing functions."""
    return SAMPLE_POLICY_TEXT

@pytest.fixture
def sample_themes():
    """Expected themes extracted from sample policy."""
    return SAMPLE_THEMES.copy()

@pytest.fixture
def sample_classification():
    """Expected classification for sample policy."""
    return SAMPLE_CLASSIFICATION.copy()

@pytest.fixture
def sample_coverage_analysis():
    """Sample ethical framework coverage analysis."""
    return {
        'accountability': {
            'score': 15.2,
            'matched_items': ['approval', 'faculty decision'],
            'item_count': 2,
            'status': 'moderate',
            'description': 'Clear assignment of responsibility and governance structures'
        },
        'transparency': {
            'score': 28.7,
            'matched_items': ['must disclose', 'clearly acknowledged', 'PHRASE: must disclose'],
            'item_count': 3,
            'status': 'moderate',
            'description': 'Clear communication and explainable AI usage'
        },
        'human_agency': {
            'score': 22.1,
            'matched_items': ['human judgment', 'faculty maintain', 'final authority'],
            'item_count': 3,
            'status': 'moderate',
            'description': 'Maintaining human control and decision-making authority'
        },
        'inclusiveness': {
            'score': 8.3,
            'matched_items': ['accessible'],
            'item_count': 1,
            'status': 'weak',
            'description': 'Ensuring equitable access and diverse perspectives'
        }
    }

@pytest.fixture
def sample_recommendations():
    """Sample recommendations generated by the engine."""
    return [
        {
            'title': 'Establish Multi-Stakeholder AI Governance Committee',
            'description': 'Create institution-wide committee comprising faculty representatives, student body delegates, IT specialists, ethics experts, and senior administrators.',
            'dimension': 'accountability',
            'priority': 'high',
            'implementation_type': 'new_implementation',
            'timeframe': '2-4 months',
            'implementation_steps': [
                'Identify and recruit diverse committee members with relevant expertise',
                'Develop committee charter defining roles, responsibilities, and decision-making authority',
                'Establish regular meeting schedule and reporting mechanisms to senior leadership',
                'Create standardised incident reporting and policy violation review processes'
            ],
            'success_metrics': ['Committee established within 2 months', 'Monthly meeting attendance >80%'],
            'source': 'UNESCO 2023',
            'recommendation_confidence': 'High'
        },
        {
            'title': 'Enhance Existing Disclosure Requirements with Methodological Detail',
            'description': 'Enhance current disclosure practices by requiring detailed documentation of AI methodologies, decision-making processes, and outcome validation procedures.',
            'dimension': 'transparency',
            'priority': 'medium',
            'implementation_type': 'enhancement',
            'timeframe': '1-2 months',
            'implementation_steps': [
                'Review and strengthen existing disclosure language for comprehensiveness',
                'Add requirements for AI methodology documentation in research contexts',
                'Create detailed examples and case studies for common disclosure scenarios'
            ],
            'success_metrics': ['Enhanced disclosure guidelines published', 'Compliance monitoring system operational'],
            'source': 'UNESCO 2023',
            'recommendation_confidence': 'Medium-High'
        }
    ]

@pytest.fixture
def temp_policy_file():
    """Create a temporary policy file for testing file processing."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
        f.write(SAMPLE_POLICY_TEXT)
        temp_path = f.name
    
    yield temp_path
    
    # Cleanup
    if os.path.exists(temp_path):
        os.unlink(temp_path)

@pytest.fixture
def temp_pdf_file():
    """Create a temporary text file (simulating processed PDF content)."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
        f.write("Sample AI policy for PDF testing")
        temp_path = f.name
    
    yield temp_path
    
    # Cleanup
    if os.path.exists(temp_path):
        os.unlink(temp_path)

@pytest.fixture
def mock_text_processor():
    """Mock TextProcessor for unit testing."""
    mock = Mock()
    mock.extract_text_from_file.return_value = SAMPLE_POLICY_TEXT
    mock.clean_text.return_value = SAMPLE_POLICY_TEXT.strip()
    mock.get_text_statistics.return_value = {
        'word_count': 150,
        'char_count': 850,
        'paragraph_count': 6,
        'sentence_count': 12
    }
    return mock

@pytest.fixture
def mock_theme_extractor():
    """Mock ThemeExtractor for unit testing."""
    mock = Mock()
    mock.extract_themes.return_value = SAMPLE_THEMES
    mock.get_theme_summary.return_value = {
        'total_themes': len(SAMPLE_THEMES),
        'avg_confidence': 85.2,
        'top_theme': 'AI Ethics'
    }
    return mock

@pytest.fixture
def mock_policy_classifier():
    """Mock PolicyClassifier for unit testing."""
    mock = Mock()
    mock.classify_policy.return_value = SAMPLE_CLASSIFICATION
    mock.get_classification_details.return_value = {
        'confidence_breakdown': {
            'restrictive_score': 0.15,
            'moderate_score': 0.67,
            'permissive_score': 0.18
        },
        'key_indicators': ['disclosure', 'approval', 'oversight']
    }
    return mock

@pytest.fixture
def mock_database_operations():
    """Mock DatabaseOperations for unit testing."""
    mock = Mock()
    mock.store_user_analysis_results.return_value = "test_analysis_123"
    mock.get_user_analyses.return_value = [
        {
            'id': 'test_analysis_123',
            'filename': 'test-policy.pdf',
            'classification': SAMPLE_CLASSIFICATION,
            'themes': SAMPLE_THEMES[:3],
            'analysis_date': datetime.now().isoformat()
        }
    ]
    mock.get_user_analysis_by_id.return_value = {
        'id': 'test_analysis_123',
        'filename': 'test-policy.pdf',
        'classification': SAMPLE_CLASSIFICATION,
        'themes': SAMPLE_THEMES,
        'text_data': {'cleaned_text': SAMPLE_POLICY_TEXT}
    }
    return mock

@pytest.fixture
def mock_recommendation_engine():
    """Mock RecommendationEngine for unit testing."""
    mock = Mock()
    mock.generate_recommendations.return_value = {
        'analysis_metadata': {
            'analysis_id': 'test_analysis_123',
            'generated_date': datetime.now().isoformat(),
            'framework_version': '2.0-enhanced',
            'methodology': 'Enhanced Ethical Framework Gap Analysis'
        },
        'coverage_analysis': pytest.lazy_fixture('sample_coverage_analysis'),
        'recommendations': pytest.lazy_fixture('sample_recommendations'),
        'summary': {
            'total_recommendations': 2,
            'high_priority_count': 1,
            'overall_coverage': 18.6
        }
    }
    return mock

@pytest.fixture
def test_user_data():
    """Sample user data for authentication testing."""
    return {
        'username': 'testuser',
        'email': 'test@example.com',
        'password': 'securepassword123',
        'first_name': 'Test',
        'last_name': 'User'
    }

@pytest.fixture
def app_config():
    """Test application configuration."""
    return {
        'TESTING': True,
        'SECRET_KEY': 'test-secret-key',
        'SQLALCHEMY_DATABASE_URI': 'sqlite:///:memory:',
        'WTF_CSRF_ENABLED': False,
        'UPLOAD_FOLDER': tempfile.gettempdir()
    }

@pytest.fixture
def clean_database():
    """Ensure clean database state for each test."""
    # This fixture would be used to reset database state
    # Implementation depends on your database setup
    yield
    # Cleanup code here

# Custom assertions for PolicyCraft testing
def assert_valid_theme(theme):
    """Assert that a theme object has required fields and valid values."""
    assert isinstance(theme, dict), "Theme should be a dictionary"
    assert 'name' in theme, "Theme should have a name"
    assert 'score' in theme, "Theme should have a score"
    assert 'confidence' in theme, "Theme should have a confidence"
    assert isinstance(theme['name'], str), "Theme name should be string"
    assert 0 <= theme['score'] <= 10, "Theme score should be between 0 and 1"
    assert 0 <= theme['confidence'] <= 100, "Theme confidence should be between 0 and 100"

def assert_valid_classification(classification):
    """Assert that a classification object has required fields and valid values."""
    assert isinstance(classification, dict), "Classification should be a dictionary"
    assert 'classification' in classification, "Classification should have classification field"
    assert 'confidence' in classification, "Classification should have confidence field"
    assert classification['classification'] in ['Restrictive', 'Moderate', 'Permissive'], \
        "Classification should be one of: Restrictive, Moderate, Permissive"
    assert 0 <= classification['confidence'] <= 100, \
        "Classification confidence should be between 0 and 100"

def assert_valid_recommendation(recommendation):
    """Assert that a recommendation object has required fields and valid values."""
    required_fields = ['title', 'description', 'dimension', 'priority']
    for field in required_fields:
        assert field in recommendation, f"Recommendation should have {field} field"
        assert isinstance(recommendation[field], str), f"Recommendation {field} should be string"
    
    assert recommendation['priority'] in ['critical', 'high', 'medium', 'low'], \
        "Recommendation priority should be valid"

# Export custom assertions for use in tests
pytest.assert_valid_theme = assert_valid_theme
pytest.assert_valid_classification = assert_valid_classification
pytest.assert_valid_recommendation = assert_valid_recommendation